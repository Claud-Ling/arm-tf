/*
 * reg2bin2.c, convert register tables into fixed style.
 *
 * Register Tables generated by I2C(ascii):
 *
 * Address(hex)		data(hex)
 *
 * Address is hexadecimal number without the prefix 0x(0X).
 * data is hexadeciaml number with the prefix 0x(0X),and the register
 * size could be concluded by the length of data(xx for byte,xxxx for hword,
 * and xxxxxxxx for word).data is LITTLE-ENDIAN,it is said by Qian Bin(Calvin).
 *
 * Fixed Style(binary):
 * 
 * Address(hex,should be in KSEG1)	databyte1	databyte2
 *
 * see ../../README to learn more!
 *
 * Author: Alan Liu(Liu Hongming)
 * TTI,Shanghai
 * 2003
 *
 * Sam modified to support i2c operation and delay (12-21-2004)
 * new script format:
 * 1. reg <address> <data>  <width>
 * 2. i2c <i2caddr> <reg> <data>
 * 3. delay <usec>
 *
 */

#define ENDIAN_CFG 1

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include "../../include/configtable.h"

//#define DEBUG

#ifdef DEBUG
#define DBG(x...) printf(x)
#else
#define DBG(x...)
#endif

int main(int argc, char **argv)
{

	FILE *src, *dst;
	char name[128];
	int offset = 0;
	char buffer[128];
	int nline = 0;
	struct S_REG_I2C_DELAY rid;
	unsigned int *ptr_convert = (unsigned int *)&rid;

	switch (argc) {

	case 2:
		strcpy(name, argv[1]);
		strcat(name, ".flash");
		break;
	case 3:
		strcpy(name, argv[2]);
		break;
	default:
		printf("help:	%s input_file [output_file]\n", argv[0]);
		printf
		    ("	if output_file is not specified,then input_file.flash is the default output_file\n");
		exit(1);
	}

	dst = fopen(name, "wb");
	if (dst == NULL) {
		printf("%s\n", strerror(errno));
		exit(1);
	}

	src = fopen(argv[1], "r");
	if (src == NULL) {
		printf("%s\n", strerror(errno));
		exit(1);
	}

	while (fgets(buffer, sizeof (buffer), src)) {
		char opcode[0x10];
		char p1[0x10], p2[0x10], p3[0x10];
		char *p = NULL;
		unsigned int width, i2c_data;

		nline++;
		DBG("%s", buffer);
		
		if (strchr(buffer, '#'))
			continue;

		memset(&rid, 0, sizeof(struct S_REG_I2C_DELAY));
		sscanf(buffer, "%s ", &opcode);

		if(!strcmp(opcode, "reg"))
			{
			sscanf(buffer, "%s %s %s %s", &opcode, &p1, &p2, &p3);
			rid.u.reg.address = strtoul(p1, NULL, 16);
			rid.u.reg.data = strtoul(p2, NULL, 16);
			rid.u.reg.width = strtoul(p3, NULL, 16);
			DBG("rid.u.reg.address:%x\n", rid.u.reg.address);
			DBG("rid.u.reg.data:%x\n", rid.u.reg.data);
			DBG("rid.u.reg.width:%x\n", rid.u.reg.width);
			}
		else if(!strcmp(opcode, "i2c"))
			{
			rid.u.i2c.width = 7;
			rid.u.i2c.opcode = 0;
			sscanf(buffer, "%s %s %s %s", &opcode, &p1, &p2, &p3);
			rid.u.i2c.i2c_addr = strtoul(p1, NULL, 16);
			
			rid.u.i2c.reg[0] = strtoul(p2, NULL, 16);
			switch(strlen(p2))
				{
				case 1:
				case 2:
					break;
				case 3:
				case 4:
					rid.u.i2c.r_wid = 1;
					rid.u.i2c.reg[1] = strtoul(p2, NULL, 16) >> 8;
					break;
				default:
					goto err_out;
					break;
				}
			
			rid.u.i2c.i2c_data[3] = strtoul(p3, NULL, 16);
			switch(strlen(p3))
				{
				case 1:
				case 2:
					break;
				case 3:
				case 4:
					rid.u.i2c.d_wid = 1;
					*((unsigned short *)&(rid.u.i2c.i2c_data[2])) = 
						strtoul(p3, NULL, 16);
					break;
				case 5:
				case 6:
				case 7:
				case 8:
					rid.u.i2c.d_wid = 2;
					*((unsigned int *)&(rid.u.i2c.i2c_data[0])) = 
						strtoul(p3, NULL, 16);
					break;
				default:
					goto err_out;
					break;
				}
			
			DBG("rid.u.i2c.width:%x\n", rid.u.i2c.width);
			DBG("rid.u.i2c.r_wid:%x\n", rid.u.i2c.r_wid);
			DBG("rid.u.i2c.d_wid:%x\n", rid.u.i2c.d_wid);
			DBG("rid.u.i2c.opcode:%x\n", rid.u.i2c.opcode);
			DBG("rid.u.i2c.i2c_addr:%x\n", rid.u.i2c.i2c_addr);
			DBG("rid.u.i2c.reg:%x %x\n", rid.u.i2c.reg[0], rid.u.i2c.reg[1]);
			DBG("rid.u.i2c.i2c_data:%x\n", *(unsigned int *)&rid.u.i2c.i2c_data[0]);
			}
		else if(!strcmp(opcode, "delay"))
			{
			rid.u.delay.width = 7;
			rid.u.delay.opcode = 1;
			sscanf(buffer, "%s %s", &opcode, &p1);
			rid.u.delay.usec = strtoul(p1, NULL, 16);
			DBG("rid.u.delay.width:%x\n", rid.u.delay.width);
			DBG("rid.u.delay.opcode:%x\n", rid.u.delay.opcode);
			DBG("rid.u.delay.usec:%x\n", rid.u.delay.usec);
			}
		else
			{
			goto err_out;
			}

		DBG("0x%08x 0x%08x\n", *ptr_convert, *(ptr_convert + 1));
		
		*ptr_convert = htonl(*ptr_convert);
		*(ptr_convert + 1) = htonl(*(ptr_convert + 1));

		DBG("0x%08x 0x%08x\n\n", *ptr_convert, *(ptr_convert + 1));
		
		fwrite((void *) &rid, 8, 1, dst);
	}
	fclose(src);
	fclose(dst);
	return 0;

err_out:
	printf("Command error at line %d", nline);
	exit(1);
}
